<!DOCTYPE html>
<html>
<head>
<style>
img {
  width: 100%;
}
</style>
</head>
<body>
<!--
-->
<script>
  var tickets = [
    { // 1 (TODO: combinators, lemmas?, theorem and other, change beta-редуцируемость)
      name:"Бестиповое лямбда-исчисление. Общие определения (альфа-эквивалентность, бета-редукция, бета-эквивалентность). Параллельная бета-редукция. Теорема Чёрча-Россера.",
      defs:["Лямда-выражение, грамматика, абстракция, аппликация", "Свободное и связанное вхождения", "Функции V и FV", "Альфа-эквивалентность", "Бета-редекс, бета-редукция", "Бета-редуцируемость, бета-эквивалентность, параллельная бета-редукция"]
    },
    { // 2 (DONE)
      name:"Булевские значения, чёрчевские нумералы, упорядоченные пары.",
      defs:["Булевские значения и функции", "Черчевские нумералы, +1", "Арифметические функции", "Пары, -1"]
    },
    { 
      name:"Алгебраические типы: аналог в теории множеств, реализация в лямбда-исчислении. Нормальный и аппликативный порядок редукций, мемоизация.",
      defs:[]
    },
    { 
      name:"Y-комбинатор. Парадокс Карри.",
      defs:[]
    },
    { 
      name:"Просто типизированное лямбда-исчисление. Исчисление по Чёрчу и по Карри. Изоморфизм КарриХоварда.",
      defs:[]
    },
    { // 6 (TODO: maybe done?)
      name:"Конъюнкция, дизъюнкция, ложь и соответствующие им конструкции в лямбда-исчислении.",
      defs:["Булевские значения и функции (билет №2)"]
    },
    { 
      name:"Нетипизируемость Y-комбинатора. Слабая и сильная нормализация.",
      defs:[]
    },
    { // 8 (TODO: 1 analog)
      name:"Задачи проверки типа, реконструкции (вывода) типа, обитаемости типа в просто типизированном лямбда-исчислении. Их аналоги в интуиционистском исчислении высказываний.",
      defs:["Задачи и соответствия"]
    },
    { 
      name:"Алгебраические термы. Задача унификации в алгебраических термах. Алгоритм унификации. Доказательство корректности алгоритма унификации. Наиболее общее решение задачи унификации.",
      defs:[]
    },
    { 
      name:"Алгоритм нахождения типа в просто типизированном лямбда-исчислении. Наиболее общий тип, наиболее общая пара.",
      defs:[]
    },
    { 
      name:"Комбинаторы. Базисы SK и BCKW, выразимость в них любого замкнутого лямбда-терма. Аналоги для комбинаторных исчислений в исчислении высказываний.",
      defs:[]
    },
    { 
      name:"Логика второго порядка. Выразимость связок через импликацию и квантор всеобщности в интуиционистской логике 2-го порядка (конъюнкция, дизъюнкция, ложь, отрицание, квантор существования).",
      defs:[]
    },
    { 
      name:"Система F. Изоморфизм Карри-Ховарда для системы F. Упорядоченные пары и алгебраические типы.",
      defs:[]
    },
    { 
      name:"Экзистенциальные типы. Конструкции unpack и pack.",
      defs:[]
    },
    { 
      name:"Ранг типа. Частный случай типа. Типы и типовые схемы. let-полиморфизм.",
      defs:[]
    },
    { 
      name:"Типовая система Хиндли-Милнера. Алгоритм W.",
      defs:[]
    },
    { 
      name:"Типизация Y-комбинатора. Экви- и изорекурсивные типы, µ-оператор, roll и unroll.",
      defs:[]
    },
    { 
      name:"Зависимые типы: примеры в языках программирования, теоретико-множественный смысл, исчисление предикатов и зависимые типы.",
      defs:[]
    },
    { 
      name:"Обобщённые типовые системы. Типы, рода, сорта. Лямбда-куб.",
      defs:[]
    },
    { 
      name:"Язык Идрис. Типизация printf с использованием зависимых типов.",
      defs:[]
    },
    { 
      name:"Типы Fin и Vect. Операция индексации, доказуемо не выходящая за границы массива.",
      defs:[]
    },
    { 
      name:"Σ и Π типы в языке Идрис. Примеры использования. Переформулировка типов на языке обобщённых типовых систем. Изоморфизм Карри-Ховарда и утверждения, соответствующие данным типам.",
      defs:[]
    },
    { 
      name:"Равенство в Идрис. Доказательства в языке Идрис (на примере коммутативности сложения). Функция replace и конструкция rewrite.",
      defs:[]
    },
    { 
      name:"Теорема Диаконеску. Типы и сетоиды.",
      defs:[]
    }
  ];

  for (i = 0; i < tickets.length; ++i) {
    var p = document.createElement("P");
    p.innerText = (i + 1) + ". " + tickets[i].name;
    document.body.appendChild(p);
    for (j = 0; j < tickets[i].defs.length; ++j) {
      var temp = (i + 1) + "_" + (j + 1);
      var temp_spoiler = "spoiler_" + temp;

      var b = document.createElement("DIV");
      b.innerHTML = "<button type=\"button\" onclick=\"toggle('" + temp_spoiler + "')\">" + tickets[i].defs[j] + "</button>";
      document.body.appendChild(b);

      var img = document.createElement("DIV");
      img.innerHTML = "<div id=\"" + temp_spoiler + "\" style=\"display:none\"><img src=\"images/" + temp + ".png\"></div>";
      document.body.appendChild(img);
    }
  }

  function toggle(name) {
    if (document.getElementById(name).style.display=='none') {
      document.getElementById(name).style.display='';
    } else {
      document.getElementById(name).style.display='none';
    }
  }
</script>
</html>
